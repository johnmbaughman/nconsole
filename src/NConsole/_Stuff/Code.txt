// check if argument is obsolete
Attribute[] attribs = (Attribute[])arg.Property.GetCustomAttributes(typeof(ObsoleteAttribute), false);
if (attribs.Length > 0)
{
    ObsoleteAttribute obsoleteAttrib = (ObsoleteAttribute)attribs[0];
    string message = string.Format(CultureInfo.InvariantCulture, ResourceUtils.GetString("NA1177"), option,obsoleteAttrib.Message);
    if (obsoleteAttrib.IsError)
    {
        throw new CommandLineArgumentException(message);
    }
    else
    {
        Console.WriteLine(string.Empty);
        Console.WriteLine("Warning: " + message);
        Console.WriteLine(string.Empty);
    }
}
========================================================================================================================
//if (option.Length + 1 == argument.Length)
//{
//    optionArgument = null;
//}
//else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':')
//{
//    optionArgument = argument.Substring(option.Length + 2);
//}
//else
//{
//    optionArgument = argument.Substring(option.Length + 1);
//}
========================================================================================================================
// check for missing required arguments
//foreach (CommandLineArgument arg in _argumentCollection)
//{
//    arg.Finish(destination);
//}
//
//if (_defaultArgument != null)
//{
//    _defaultArgument.Finish(destination);
//}
========================================================================================================================
//        public string ShortName
//        {
//            get
//            {
//                if (_attribute != null && !string.IsNullOrEmpty(_attribute.ShortName))
//                {
//                    return _attribute.ShortName;
//                }
//                return null;
//            }
//        }

        //public string Description {
        //public bool IsRequired {
        //public bool SeenValue {
        //public bool AllowMultiple {
        //public bool Unique {
        //public Type Type {
        //public bool IsCollection {
        //public bool IsNameValueCollection {
        //public bool IsArray {
        //public bool IsDefault {
        //public bool IsExclusive {
        //public void Finish(object destination) {

//            if (SeenValue && !AllowMultiple)
//            {
//                throw new CommandLineArgumentException(string.Format("", LongName));
//            }
//
//            _seenValue = true;
//
//            object newValue = ParseValue(ValueType, value);
//
//            if (IsCollection || IsArray)
//            {
//                if (Unique && _collectionValues.Contains(newValue))
//                {
//                    throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture,
//                        ResourceUtils.GetString("NA1172"), value, LongName));
//                }
//                else
//                {
//                    _collectionValues.Add(newValue);
//                }
//            }
//            else if (IsNameValueCollection)
//            {
//                // name/value pair is added to collection in ParseValue
//            }
//            else
//            {
                //_argumentValue = /*newValue*/value;
//            }
        }

        //private object ParseValue(Type type, string stringData) {
        //private static CommandLineArgumentTypes GetArgumentType(CommandLineArgumentAttribute attribute, PropertyInfo propertyInfo) {
        //private static Type GetElementType(PropertyInfo propertyInfo) {
        //private static bool IsNameValueCollectionType(Type type) {
        //private static bool IsCollectionType(Type type) {
        //private static bool IsArrayType(Type type) {
========================================================================================================================
        /// <summary>
        /// Inspects the type.
        /// </summary>
        /// <param name="type"></param>
        public void Inspect(Type type)
        {
            // Ensure we have an ICommand
            if (!typeof(ICommand).IsAssignableFrom(type))
            {
                throw new Exception(string.Format("Type '{0}' does not implement ICommand.", type.FullName));
            }
        }



//private readonly IList<CommandDescriptor> commandDescriptors = new List<CommandDescriptor>();

//        public void Register(Type commandType)
//        {
//            // Build a command descriptor
//            CommandDescriptor descriptor = CommandDescriptor.FromType(commandType);
//            commandDescriptors.Add(descriptor);
//        }

        // <summary>
        // Registers the command type with the factory so that it can be resolved.
        // </summary>
        // <param name="commandType"></param>
        //void Register(Type commandType);

//        public ICommand CreateCommand(string commandName)
//        {
//            foreach (CommandDescriptor descriptor in commandDescriptors)
//            {
//                if (descriptor.Name == commandName)
//                {
//                    return Activator.CreateInstance(descriptor.CommandType) as ICommand;
//                }
//            }
//            return null;

            //return Activator.CreateInstance(descriptor.CommandType) as ICommand;
        //}

//        public IEnumerable<CommandDescriptor> CommandDescriptors
//        {
//            get { return commandDescriptors; }
//        }


================


//        [Test]
//        public void CanRegisterCommandAndRetrieveCommandDescriptor()
//        {
//            // Arrange
//            DefaultCommandFactory commandFactory = new DefaultCommandFactory();
//            commandFactory.Inspect(typeof(TestCommand));
//
//            // Act
//            //var descriptors = commandFactory.CommandDescriptors;
//
//            // Assert
//            //Assert.AreEqual(1, descriptors.Count());
//            //Assert.AreEqual(typeof(TestCommand), descriptors.First().CommandType);
//        }

        [Test, Ignore]
        public void Inspect_ThrowsIfCommandDoesNotImplementICommand()
        {
            // Arrange
            DefaultCommandFactory commandFactory = new DefaultCommandFactory();

            // Act
            var ex = Record.Exception(() => commandFactory.Inspect(typeof(int)));

            // Assert
            Assert.AreEqual("Type 'System.Int32' does not implement ICommand.", ex.Message);
        }

        [Test, Ignore]
        public void CanResolveCommand()
        {
            // Arrange
            DefaultCommandFactory commandFactory = new DefaultCommandFactory();
            //commandFactory.Register(typeof(TestCommand));

            // Act
            //ICommand command = commandFactory.Create("test");

            // Assert
            //Assert.IsNotNull(command);
            //Assert.IsInstanceOf<TestCommand>(command);
        }

        [Test, Ignore]
        public void CanResolveSecondCommandRegistered()
        {
            // Arrange
            DefaultCommandFactory commandFactory = new DefaultCommandFactory();
            //commandFactory.Register(typeof(TestCommand));
            //commandFactory.Register(typeof(Test2Command));

            // Act
            //ICommand command = commandFactory.Create("test2");

            // Assert
            //Assert.IsNotNull(command);
            //Assert.IsInstanceOf<Test2Command>(command);
        }


		
		if (string.IsNullOrEmpty(name))
            {
                throw new CommandLineArgumentException("Command line arguments must have a name. Use the default " +
                    "constructor if the name should match the property name.");
            }

			
			
//        [Test]
//        public void ExecuteNamedCommand()
//        {
//            // Arrange
//            CloneCommand cloneCommand = MockRepository.GenerateStub<CloneCommand>();
//
//            ICommandFactory commandFactory = MockRepository.GenerateStub<ICommandFactory>();
//            commandFactory.Stub(f => f.Create("clone")).Return(cloneCommand);
//
//            var controller = new ConsoleController(commandFactory);
//            controller.Register(typeof(CloneCommand));
//
//            // Act
//            int exitCode = controller.Execute(new[] { "clone" });
//
//            // Assert
//            Assert.AreEqual(0, exitCode);
//            cloneCommand.AssertWasCalled(c => c.Execute());
//        }
//
//        [Test]
//        public void ExecuteNamedCommandWhenItWasNotRegisteredFirst()
//        {
//            // Arrange
//            CloneCommand cloneCommand = MockRepository.GenerateStub<CloneCommand>();
//            CommitCommand commitCommand = MockRepository.GenerateStub<CommitCommand>();
//
//            ICommandFactory commandFactory = MockRepository.GenerateStub<ICommandFactory>();
//            commandFactory.Stub(f => f.Create("clone")).Return(cloneCommand);
//            commandFactory.Stub(f => f.Create("commit")).Return(commitCommand);
//
//            var controller = new ConsoleController(commandFactory);
//            controller.Register(typeof(CloneCommand));
//            controller.Register(typeof(CommitCommand));
//
//            // Act
//            int exitCode = controller.Execute(new[] { "commit" });
//
//            // Assert
//            Assert.AreEqual(0, exitCode);
//            commitCommand.AssertWasCalled(c => c.Execute());
//        }

        [Test, Ignore]
        public void ExecuteNamedCommandThatWasNotRegistered()
        {
            // Arrange
            ICommandFactory commandFactory = MockRepository.GenerateStub<ICommandFactory>();

            var controller = new ConsoleController(commandFactory);

            // Act
            int exitCode = controller.Execute(new[] { "random" });

            // Assert
            Assert.AreEqual(0, exitCode);
        }

//        public class CloneCommand : ICommand
//        {
//            [Argument(Mandatory = true)]
//            public Uri Repository { get; set; }
//
//            [Argument]
//            public DirectoryInfo Directory { get; set; }
//
//            public virtual void Execute()
//            {
//            }
//        }

        public class CommitCommand : ICommand
        {
            public string Message { get; set; }

            public virtual void Execute()
            {
            }
        }
		
        // <summary>
        // Registers a type that implements <see cref="ICommand"/>.
        // </summary>
        // <param name="commandType"></param>
//        public void Register(Type commandType)
//        {
//            descriptors.Add(CommandDescriptor.FromType(commandType));
//        }

